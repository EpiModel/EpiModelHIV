% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utilities.R
\name{ego.netest}
\alias{ego.netest}
\title{Convert ergm.ego fit to netest object}
\usage{
ego.netest(eefit, disscoef, obs.adjust = FALSE, obs.offset = 52)
}
\arguments{
\item{eefit}{An object of class \code{ergm.ego} output from the 
\code{ergm.ego} function in the ergm.ego package.}

\item{disscoef}{An object of class \code{disscoef} output from the 
\code{dissolution_coefs} function in the EpiModel package.}

\item{obs.adjust}{Are the partner counts taken over a period 
different than the simulation step length? Typically
used for one-time partner models.}

\item{obs.offset}{A value representing the partner count observation 
period in simulation time steps.
The edges coefficient in the formation model is adjusted 
by \code{-log(obs.offset)}
The default (52) assumes the partner count is over the 
last year, and the simulation step is one week.}
}
\value{
This function returns a \code{netest} for use with EpiModel functions. The output is organized as a list of 9 objects, 
        including \code{fit}, \code{formation}, \code{target.stats}, \code{target.stats.names}, 
        \code{coef.form}, \code{dissolution}, \code{coef.diss}, \code{constraints}, \code{edapprox}. 
        \item{"fit"}{Fitting object from \code{ergm.ego}.}
        \item{"fit$coef"}{Estimated coefficents from \code{ergm.ego}.}
        \item{"fit$sample"}{A list of matrices storing MCMC samples for each coefficient.}
        \item{"fit$iterations"}{The number of Newton-Raphson iterations required before convergence.}
        \item{"fit$MCMCtheta"}{The value of \eqn{\theta} used to produce the Markov Chain Monte Carlo samples.}
        \item{"fit$loglikelihood"}{The approximate change in log-likelihood in the last iteration. The value is only approximate because it is estimated based on the MCMC random sample.}
        \item{"fit$gradiant"}{The value of the gradient vector of the approximated loglikelihood function, evaluated at the maximizer. This vector should be very close to zero.}
        \item{"fit$hessian"}{}
        \item{"fit$covar"}{Approximate covariance matrix for the MLE, based on the inverse Hessian of the approximated loglikelihood evaluated at the maximizer.}
        \item{"fit$failure"}{Logical: Did the MCMC estimation fail?}
        \item{"fit$network"}{Original network.}
        \item{"fit$newnetwork"}{The final network at the end of the MCMC simulation.}
        \item{"fit$newnetworks"}{}
        \item{"fit$coef.init"}{The initial value \eqn{\theta}.}
        \item{"fit$est.cov"}{The covariance matrix of the model statistics in the final MCMC sample.}
        \item{"fit$coef.hist"&"$stats.hist"&"$steplen.hist"}{For the MCMLE method, the history of coefficients, Hummel step lengths, and average model statistics for each iteration.}
        \item{"fit$control"}{A list of control parameters for algorithm tuning.}
        \item{"fit$etamap"}{The set of functions mapping the true parameter theta to the canonical parameter eta (irrelevant except in a curved exponential family model).}
        \item{"fit$formula"}{The original formula used in \code{ergm.ego} function}
        \item{"fit$target.stats"}{The target stats used for estimation.}
        \item{"fit$target.esteq"}{Used for curved models to preserve the target mean values of the curved terms. It is identical to target.stats for non-curved models.}
        \item{"fit$constraints"}{Constraints used during estimation (passed through from the Arguments).}
        \item{"fit$reference"}{The reference measure used during estimation (passed through from the Arguments).}
        \item{"fit$estimate"}{The estimation method used (passed through from the Arguments).}
        \item{"fit$offset"}{Vector of logical telling which model parameters are to be set at a fixed value (i.e., not estimated).}
        \item{"fit$drop"}{}
        \item{"fit$estimable"}{A logical vector indicating which terms could not be estimated due to a constraints constraint fixing that term at a constant value.}
        \item{"fit$null.lik"}{Log-likelihood of the null model. Valid only for unconstrained models.}
        \item{"formation"}{The original formation formula}
        \item{"target.stats"}{The target stats used for estimation}
        \item{"target.stats.names"}{The names of the target stats.}
        \item{"coef.form"}{The coefficients of the formation model.}
        \item{"coef.diss"}{The coefficients of the dissolution model.}
        \item{"constraints"}{}
        \item{"edapprox"}{Logical}
}
\description{
Converts an ergm.ego output object and a dissolution
coef (output from Epimodel function \code{dissolution_coefs} 
to a netest object for use in EpiModel.  Started from \code{ee.netest}.
}
\examples{

\dontrun{
 ergm.ego model
  library(ergm.ego)
 data(faux.mesa.high)
 fmh.ego <- as.egodata(faux.mesa.high)
 ego_fit <- ergm.ego(fmh.ego~edges+degree(0:3)
                    +nodefactor("Race")+nodematch("Race")
                    +nodefactor("Sex")+nodematch("Sex")
                    +absdiff("Grade"),
                    ppopsize="samp") # uses size of fmh for ppop
 
 # Also works - use to test having an offset, this one prevents same sex ties
 ego_fit2 <- ergm.ego(fmh.ego~edges+offset(nodematch("Sex", diff=FALSE)),
                    offset.coef=c(-Inf),
                    ppopsize="samp") # as above
 
 #----------------------------
 # Homogeneous dissolution model (note, model specified now with EpiModel)
 library(EpiModel)
 diss = ~offset(edges)
 ## Need to set two times:  mean partnership duration, mean lifespan
 ## here we use lifespan = 100*partnershp duration
 coef.diss <- dissolution_coefs(dissolution = diss,
                                duration = 40, 
                                d.rate = 1/(100*40))
 
 ## Translate the ergm.ego fit object into a netest object
 netest_fit <- egonet::ego.netest(ego_fit, coef.diss)
 
 # netdx, static, note monitoring of non-model terms
 dx1 <- netdx(netest_fit, nsims = 1e4, dynamic = FALSE,
              nwstats.formula = ~edges + meandeg + concurrent)
 dx1
 plot(dx1, method = "b", stats = c("edges", "concurrent"))
 
 # netdx, dynamic
 dx2 <- netdx(netest_fit, nsims = 5, nsteps = 1000,
              nwstats.formula = ~edges + meandeg + concurrent,
              set.control.ergm = control.simulate.ergm(MCMC.burnin = 1e6))
 dx2
 plot(dx2, stats = c("edges", "meandeg"), plots.joined = FALSE)
 plot(dx2, type = "duration")
 plot(dx2, type = "dissolution", qnts.col = "orange2")
 plot(dx2, type = "dissolution", method = "b", col = "bisque")
 
 
 #----------------------------
 # Dissolution varies by Race
 ## Note for this to work, all terms in the dissolution model
 ## must also be in the formation model, and in the same order in
 ## both models, with the common terms at the front of the formation
 ## model specification
 
 dissR <- ~offset(edges) + offset(nodematch("Race", diff=TRUE))
 coef.dissR <- dissolution_coefs(dissolution = dissR,
                                 duration = c(30, 10, 20, 30, 10, 40))
 netestR_fit <- egonet::ego.netest(ego_fit, coef.dissR)
 
 dxR1 <- netdx(netestR_fit, nsims=1e4, dynamic=FALSE) # static draws
 plot(dxR1, method = "b")
 
 # see what happens when sequential=F, static draws from same initial net
 dxR2 <- netdx(netestR_fit, nsims=5, nsteps=1000, 
               dynamic=FALSE, sequential=FALSE, 
               set.control.ergm=control.simulate.ergm(MCMC.burnin=1e6))
 dxR2
 plot(dxR2, plots.joined = FALSE)
 
 # Now with dynamic=T, note it doesn't look great, may need larger interval
 dxR3 <- netdx(netestR_fit, nsims=5, nsteps=1000, 
               set.control.ergm=control.simulate.ergm(MCMC.burnin=1e6))
 plot(dxR3, plots.joined = FALSE)
 plot(dxR3, type = "duration")
 plot(dxR3, type = "dissolution", qnts.col = "orange2")
 plot(dxR3, type = "dissolution", method = "b", col = "bisque")

}

}
\keyword{class}
\keyword{convert}
\keyword{module}
\keyword{object}
